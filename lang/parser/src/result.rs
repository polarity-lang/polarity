use miette::{Diagnostic, SourceOffset, SourceSpan};
use thiserror::Error;

use crate::lexer::{LexicalError, Token};

fn separated<I: IntoIterator<Item = String>>(s: &str, iter: I) -> String {
    let vec: Vec<_> = iter.into_iter().collect();
    vec.join(s)
}
fn comma_separated<I: IntoIterator<Item = String>>(iter: I) -> String {
    separated(", ", iter)
}

#[derive(Error, Diagnostic, Debug, Clone)]
pub enum ParseError {
    /// Generated by the parser when it encounters a token (or EOF) it did not
    /// expect.
    #[error("Invalid token")]
    #[diagnostic(code("P-001"))]
    InvalidToken {
        #[label]
        span: Option<SourceSpan>,
    },

    /// Generated by the parser when it encounters an EOF it did not expect.
    #[error("Unexpected end of file. Expected {expected}")]
    #[diagnostic(code("P-002"))]
    UnrecognizedEof {
        #[label]
        location: SourceOffset,
        expected: String,
    },

    /// Generated by the parser when it encounters a token it did not expect.
    #[error("Unexpected \"{token}\", expected {expected}")]
    #[diagnostic(code("P-003"))]
    UnrecognizedToken {
        token: String,
        #[label]
        span: SourceSpan,
        expected: String,
    },

    /// Generated by the parser when it encounters additional, unexpected tokens.
    #[error("Excessive \"{token}\"")]
    #[diagnostic(code("P-004"))]
    ExtraToken {
        token: String,
        #[label]
        span: SourceSpan,
    },

    #[error("A character literal must contain exactly one character")]
    #[diagnostic(code("P-005"))]
    InvalidCharLiteral {
        #[label]
        span: SourceSpan,
    },

    #[error("Invalid or incomplete escape sequence")]
    #[diagnostic(code("P-006"))]
    InvalidEscapeSequence {
        #[label]
        span: SourceSpan,
    },

    #[error("Invalid unicode escape sequence")]
    #[diagnostic(help(
        "A valid unicode escape sequence is of the form \\u{{XXX}} where XXX is a hexadecimal number with 1-6 digits"
    ))]
    #[diagnostic(code("P-007"))]
    MalformedUnicodeEscape {
        #[label]
        span: SourceSpan,
    },

    #[error("This does not correspond to a valid unicode codepoint")]
    #[diagnostic(code("P-008"))]
    InvalidUnicodeCodepoint {
        #[label]
        span: SourceSpan,
    },

    #[error("Invalid hexadecimal number")]
    #[diagnostic(code("P-009"))]
    InvalidHexNumber {
        #[label]
        span: SourceSpan,
    },

    #[error("An unexpected internal error occurred: {message}")]
    #[diagnostic(code("P-XXX"))]
    /// This error should not occur.
    /// Some internal invariant has been violated.
    Impossible {
        message: String,
        #[label]
        span: Option<SourceSpan>,
    },
}

impl From<lalrpop_util::ParseError<usize, Token, LexicalError>> for ParseError {
    fn from(err: lalrpop_util::ParseError<usize, Token, LexicalError>) -> Self {
        use lalrpop_util::ParseError::*;
        match err {
            // Impossible branch, since we do not use the internal lexer.
            // > Generated by the internal lexer when it encounters a token (or EOF) it did not expect.
            // <https://docs.rs/lalrpop-util/0.22.2/lalrpop_util/enum.ParseError.html>
            InvalidToken { location } => ParseError::Impossible {
                message:
                    "This error can only be generated by the internal LALRPOP lexer which we don't use"
                        .to_string(),
                span: Some(location.into()),
            },
            UnrecognizedEof { location, expected } => ParseError::UnrecognizedEof {
                location: location.into(),
                expected: comma_separated(expected),
            },
            UnrecognizedToken { token, expected } => ParseError::UnrecognizedToken {
                token: token.string(),
                span: token.span(),
                expected: comma_separated(expected),
            },
            ExtraToken { token } => {
                ParseError::ExtraToken { token: token.string(), span: token.span() }
            }
            User { error } => match error {
                LexicalError::InvalidToken(span) => ParseError::InvalidToken { span: span.map(Into::into) },
                LexicalError::InvalidCharLiteral(span) => ParseError::InvalidCharLiteral { span: span.into() },
                LexicalError::InvalidEscapeSequence(span) => ParseError::InvalidEscapeSequence { span: span.into() },
                LexicalError::MalformedUnicodeEscape(span) => ParseError::MalformedUnicodeEscape { span: span.into() },
                LexicalError::InvalidUnicodeCodepoint(span) => ParseError::InvalidUnicodeCodepoint { span: span.into() },
                LexicalError::InvalidHexNumber(span) => ParseError::InvalidHexNumber { span: span.into() },
            }
        }
    }
}

trait ToMietteExt {
    fn string(&self) -> String;
    fn span(&self) -> SourceSpan;
}

impl ToMietteExt for (usize, Token, usize) {
    fn span(&self) -> SourceSpan {
        (self.0, self.2 - self.0).into()
    }

    fn string(&self) -> String {
        self.1.to_string()
    }
}
