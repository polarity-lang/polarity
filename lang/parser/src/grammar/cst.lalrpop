use num_bigint::BigUint;

use crate::cst::exp::*;
use crate::cst::decls::*;
use crate::cst::ident::*;
use crate::lexer::{Token, LexicalError};

use super::util::span;

#[LALR]
grammar;

// Tokens
extern {
  type Location = usize;
  type Error = LexicalError;

  enum Token {
    // Keywords
    //
    //
    "data" => Token::Data,
    "codata" => Token::Codata,
    "def" => Token::Def,
    "codef" => Token::Codef,
    "let" => Token::Let,
    "match" => Token::Match,
    "as" => Token::As,
    "comatch" => Token::Comatch,
    "absurd" => Token::Absurd,
    "Type" => Token::Type,
    "implicit" => Token::Implicit,
    "use" => Token::Use,

    // Parens, Braces and Brackets
    //
    //
    "(" => Token::LParen,
    ")" => Token::RParen,
    "{" => Token::LBrace,
    "}" => Token::RBrace,
    "[" => Token::LBracket,
    "]" => Token::RBracket,

    // Symbols
    //
    //
    ";" => Token::Semicolon,
    ":=" => Token::ColonEq,
    "=>" => Token::DoubleRightArrow,
    "," => Token::Comma,
    ":" => Token::Colon,
    "." => Token::Dot,
    "?" => Token::QuestionMark,
    "->" => Token::RightArrow,
    "\\" => Token::Backslash,
    "#" => Token::Hash,
    "_" => Token::Underscore,

    // Identifiers
    //
    //
    "Identifier" => Token::Ident(<String>),

    // Literals
    //
    //
    "NumLit" => Token::NumLit(<BigUint>),
    "StringLit" => Token::StringLit(<String>),

    // DocComments
    "DocComment" => Token::DocComment(<String>),
  }
}

// Utils
// Based in part on Gluons grammar (https://github.com/gluon-lang/gluon/blob/fac08dcff7a019440dd8d0a886abdb18baa58198/parser/src/grammar.lalrpop)

Comma<Rule>: Vec<Rule> =
    <rules: (<Rule> ",")*> <last: Rule?> => {
        let mut rules = rules;
        rules.extend(last);
        rules
    };

Parens<Rule>: Rule =
    "(" <rule: Rule> ")" => rule;

Braces<Rule>: Rule =
    "{" <rule: Rule> "}" => rule;

Brackets<Rule>: Rule =
    "[" <rule: Rule> "]" => rule;

ParenthesizedArgs<Rule>: Vec<Rule> = Parens<Comma<Rule>>;
OptParenthesizedArgs<Rule>: Vec<Rule> = <args: Parens<Comma<Rule>>?> => args.unwrap_or_default();

BracedArgs<Rule>: Vec<Rule> = Braces<Comma<Rule>>;
OptBracedArgs<Rule>: Vec<Rule> = <args: Braces<Comma<Rule>>?> => args.unwrap_or_default();

BracketedArgs<Rule>: Vec<Rule> = Brackets<Comma<Rule>>;
OptBracketedArgs<Rule>: Vec<Rule> = <args: Brackets<Comma<Rule>>?> => args.unwrap_or_default();

Param: Param = <implicit: "implicit"?> <name: BindingSite> <names: BindingSite*> ":" <typ: Exp> => Param { implicit: implicit.is_some(), name, names, typ } ;

Params: Vec<Param> = ParenthesizedArgs<Param>;
OptParams: Vec<Param> = OptParenthesizedArgs<Param>;

Telescope: Telescope = <params: Params> => Telescope(params);
OptTelescope: Telescope = <params: OptParams> => Telescope(params);


OptTelescopeInst: Vec<BindingSite> = <params: Parens<Comma<BindingSite>>?> => params.unwrap_or_default();

Args: Vec<Arg> = ParenthesizedArgs<Arg>;
OptArgs: Vec<Arg> = OptParenthesizedArgs<Arg>;

Attr: String = <s:"Identifier"> => s.to_owned();
Attributes: Attributes = "#" <attrs: BracketedArgs<Attr>> => Attributes { attrs };
OptAttributes: Attributes = <attr: Attributes? > => attr.unwrap_or_default();

DocCommentHelper: String = <doc: "DocComment"> => doc.strip_prefix("-- |").unwrap().trim().to_owned();
DocComment: DocComment = <docs: DocCommentHelper+> => DocComment { docs };

Arg: Arg = {
  <e: Exp> => Arg::UnnamedArg(e),
  <i: Ident> ":=" <e: Exp> => Arg::NamedArg(i,e),
}

// Modules
//
//

pub ModuleContents: ModuleContents = {
    <use_decls: UseDecl*> <decls: Decls> => ModuleContents { use_decls, decls }
}

pub UseDecl: UseDecl = {
  "use" <lit: "StringLit"> => UseDecl::String(lit),
}

pub Decls: Vec<Decl> = {
    <items: Decl*> => items,
}

pub Decl: Decl = {
    <d: Data> => Decl::Data(d),
    <d: Codata> => Decl::Codata(d),
    <d: Def> => Decl::Def(d),
    <d: Codef> => Decl::Codef(d),
    <d: Let> => Decl::Let(d),
}

// Data Type Declarations
//
//

Ctor: Ctor = {
    <l: @L> <doc: DocComment?> <name: Ident> <params: OptTelescope> <typ: (":" <TypApp>)?> <r: @R> => Ctor { span: span(l, r), doc, name, params, typ },
}

// Toplevel data type declaration
Data: Data = <l: @L> <doc: DocComment?> <attr: OptAttributes> "data" <name: Ident> <params: OptTelescope> "{" <ctors: Comma<Ctor>> "}" <r: @R> =>
  Data { span: span(l, r), doc, name, attr, params, ctors };


// Codata Type Declarations
//
//

pub Destructee: Destructee = {
    <l: @L> <scrutinee: (<Scrutinee>)?> <r: @R> => match scrutinee {
        Some(Scrutinee { span, name, typ }) => Destructee { span, name, typ: Some(typ) },
        None => Destructee { span: span(l, r), name: None, typ: None },
    }
}

Dtor: Dtor = {
    <l: @L> <doc: DocComment?> <destructee: Destructee> "." <name: Ident> <params: OptTelescope> ":" <ret_typ: Exp> <r: @R> =>
      Dtor { span: span(l, r), doc, name, params, destructee, ret_typ },
}

// Toplevel codata type declaration
Codata: Codata = <l: @L> <doc: DocComment?> <attr: OptAttributes> "codata" <name: Ident> <params: OptTelescope> "{" <dtors: Comma<Dtor>> "}" <r: @R> =>
  Codata { span: span(l, r), doc, name, attr, params, dtors };


// Toplevel definition
//
//
Def: Def = <l: @L> <doc: DocComment?> <attr: OptAttributes> "def" <scrutinee: Scrutinee> "." <name: Ident> <params: OptTelescope> ":" <ret_typ: Exp> "{" <cases: Comma<Case<Pattern>>> "}" <r: @R> =>
  Def { span: span(l, r), doc, name, attr, params, scrutinee, ret_typ, cases };

// Toplevel codefinition
Codef: Codef = <l: @L> <doc: DocComment?> <attr: OptAttributes> "codef" <name: Ident> <params: OptTelescope> ":" <typ: TypApp> "{" <cases: Comma<Case<Copattern>>> "}" <r: @R> =>
  Codef { span: span(l, r), doc, name, attr, params, typ, cases };

// Toplevel let binding
Let: Let = <l: @L> <doc: DocComment?> <attr: OptAttributes> "let" <name: Ident><params: OptTelescope> ":" <typ: Exp> "{" <body: Exp> "}" <r: @R> =>
  Let { span: span(l,r), doc, name, attr, params, typ, body };


Pattern: Pattern = {
  <name: Ident><params: OptTelescopeInst> => Pattern { name, params },
}

Copattern: Copattern = {
  "." <name: Ident><params: OptTelescopeInst> => Copattern { name, params },
}

Case<P> : Case<P> = {
    <l: @L> <pattern: P> <body: AbsurdOrBody> <r: @R> => Case { span: span(l, r), pattern, body },
}

AbsurdOrBody: Option<Box<Exp>> = {
    "absurd" => None,
    "=>" <body: Exp> => Some(body),
}


pub Scrutinee: Scrutinee = {
    <l: @L> "(" <name: BindingSite> ":" <typ: TypApp> ")" <r: @R> => Scrutinee { span: span(l, r), name: match name { BindingSite::Wildcard{..} => None, BindingSite::Var { name,.. } => Some(name) }, typ },
    <l: @L> <typ: TypApp> <r: @R> => Scrutinee { span: span(l, r), name: None, typ },
}

pub TypApp: Call = {
    <l: @L> <name: Ident> <args: OptArgs> <r: @R> => Call { span: span(l, r), name, args },
}

// Expressions
//
//

pub Exp: Box<Exp> = {
    <e: Anno> => Box::new(Exp::Anno(e)),
    <e: Fun> => Box::new(Exp::Fun(e)),
    <e: Lam> => Box::new(Exp::Lam(e)),
    Ops,
}

pub Ops = {
    <e: DotCall> => Box::new(Exp::DotCall(e)),
    <e: LocalMatch> => Box::new(Exp::LocalMatch(e)),
    App,
}

pub App = {
    <e: CallWithArgs> => Box::new(Exp::Call(e)),
    <e: LocalComatch> => Box::new(Exp::LocalComatch(e)),
    Builtins,
}

pub Builtins: Box<Exp> = {
    <e: TypeUniv> => Box::new(Exp::TypeUniv(e)),
    Holes,
}

pub Holes: Box<Exp> = {
    <e: Hole> => Box::new(Exp::Hole(e)),
    Atom,
}

pub Atom: Box<Exp> = {
    <e: NatLit> => Box::new(Exp::NatLit(e)),
    "(" <exp: Exp> ")" => exp,
    <e: CallWithoutArgs> => Box::new(Exp::Call(e)),
}

// Constituent parts of expressions
//
//

Anno: Anno = <l: @L> <exp: Ops> ":" <typ: Exp> <r: @R> =>
  Anno { span: span(l, r), exp, typ };

Fun: Fun = <l: @L> <from: Ops> "->" <to: Exp> <r: @R> =>
  Fun { span: span(l, r), from, to };

Lam: Lam = <l: @L> "\\" <var: BindingSite> "." <body: Exp> <r: @R> =>
  Lam { span: span(l, r), var, body };

DotCall: DotCall = <l: @L> <exp: Ops> "." <name: Ident> <args: OptArgs> <r: @R> =>
  DotCall { span: span(l, r), exp, name, args };

LocalMatch: LocalMatch = <l: @L> <on_exp: Ops> "." "match" <name: Ident?> <motive: Motive?> "{" <cases: Comma<Case<Pattern>>> "}" <r: @R> =>
  LocalMatch { span: span(l, r), name, on_exp, motive, cases };

CallWithArgs: Call = <l: @L> <name: Ident> <args: Args> <r: @R> =>
  Call { span: span(l, r), name, args };

CallWithoutArgs: Call = <l: @L> <name: Ident> <r: @R> =>
  Call { span: span(l, r), name, args: vec![] };

LocalComatch: LocalComatch = <l: @L> "comatch" <name: Ident?> "{" <cases: Comma<Case<Copattern>>> "}" <r: @R> =>
  LocalComatch { span: span(l, r), name, is_lambda_sugar: false, cases };

TypeUniv: TypeUniv = <l: @L> "Type" <r: @R> =>
  TypeUniv { span: span(l, r) };

Hole: Hole = <l: @L> "?" <r: @R> =>
  Hole { span: span(l, r) };

NatLit: NatLit = <l: @L> <n: "NumLit"> <r: @R> =>
  NatLit { span: span(l, r), val: n };

// Helpers
//
//

Motive: Motive = {
    <l: @L> "as" <param: BindingSite> "=>" <ret_typ: Exp> <r: @R> => Motive { span: span(l, r), param, ret_typ },
}

// Names

BindingSite: BindingSite = {
    <l: @L> <i: Ident> <r: @R> => BindingSite::Var { span: span(l,r), name: i },
    <l: @L> "_" <r: @R> => BindingSite::Wildcard { span: span(l,r) },
}

Ident: Ident = {
    <i: "Identifier"> => Ident { id: i.to_owned() }
}
