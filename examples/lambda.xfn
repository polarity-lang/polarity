data Bot {}

def Bot.elim_bot(a: Type): a {}

data Eq (a: Type, x y: a) {
    Refl(a: Type, x: a) : Eq(a, x, x)
}

codata Fun(a b: Type) {
    Fun(a, b).ap(a: Type, b: Type, x: a) : b
}

def Eq(a, x, y).sym(a: Type, x: a, y: a) : Eq(a, y, x) {
    Refl(a, x) => Refl(a, x)
}

def Eq(a, x, y).transport(a: Type, x: a, y: a, p: Fun(a, Type), prf: p.ap(a, Type, x)) : p.ap(a, Type, y) {
    Refl(a, x) => prf
}

def Eq(a, x, y).cong(a: Type, b: Type, x: a, y: a, f: Fun(a, b)) : Eq(b, f.ap(a, b, x), f.ap(a, b, y)) {
    Refl(a, x) => Refl(b, f.ap(a, b, x))
}

data Exists(a: Type, p: Fun(a, Type)) {
    MkExists(a: Type, p: Fun(a, Type), x: a, prf: p.ap(a, Type, x)): Exists(a, p)
}

data Or(a: Type, b: Type) {
    Inl(a: Type, b: Type, x: a) : Or(a, b),
    Inr(a: Type, b: Type, x: b) : Or(a, b),
}

codata And(a: Type, b: Type) {
    And(a, b).proj1(a : Type, b : Type) : a,
    And(a, b).proj2(a : Type, b : Type) : b,
}

data Bool { True, False }

def Bool.then_else(a: Type, then else: a): a {
    True => then,
    False => else,
}

data Nat {
    Z,
    S(n: Nat)
}

def Nat.add(y: Nat) : Nat {
    Z => y,
    S(x) => S(x.add(y)),
}

def Nat.pred : Nat {
    Z => Z,
    S(x) => x,
}

def Nat.eq(y: Nat): Bool {
    Z => y.match {
        Z => True,
        S(_) => False,
    },
    S(x) => y.match {
        Z => False,
        S(y') => x.eq(y')
    }
}

def Top.nat_eq_reflection(x: Nat, y: Nat)
    : Or(
        Eq(Bool, x.eq(y), False),
        And(Eq(Bool, x.eq(y), True), Eq(Nat, x, y))
    ) {
    Unit => x.match as x => Or(
        Eq(Bool, x.eq(y), False),
        And(Eq(Bool, x.eq(y), True), Eq(Nat, x, y))
    ) {
        Z => y.match as y => Or(
        Eq(Bool, Z.eq(y), False),
        And(Eq(Bool, Z.eq(y), True), Eq(Nat, Z, y))
     ) {
            Z => Inr(Eq(Bool, True, False), And(Eq(Bool, True, True), Eq(Nat, Z, Z)),
                comatch {
                    proj1(_, _) => Refl(Bool, True),
                    proj2(_, _) => Refl(Nat, Z),
                }
            ),
            S(y') => Inl(Eq(Bool, False, False), And(Eq(Bool, False, True), Eq(Nat, Z, S(y'))),
                Refl(Bool, False)),
        },
        S(x') => y.match as y => Or(
            Eq(Bool, S(x').eq(y), False),
            And(Eq(Bool, S(x').eq(y), True), Eq(Nat, S(x'), y))
        ) {
            Z => Inl(Eq(Bool, False, False), And(Eq(Bool, False, True), Eq(Nat, S(x'), Z)), Refl(Bool, False)),
            S(y') => Unit.nat_eq_reflection(x', y').match {
                Inl(_, _, prf) => Inl(Eq(Bool, x'.eq(y'), False), And(Eq(Bool, x'.eq(y'), True), Eq(Nat, S(x'), S(y'))), prf),
                Inr(_, _, prf) => Inr(Eq(Bool, x'.eq(y'), False), And(Eq(Bool, x'.eq(y'), True), Eq(Nat, S(x'), S(y'))),
                    comatch {
                        proj1(_, _) => prf.proj1(Eq(Bool, x'.eq(y'), True), Eq(Nat, x', y')),
                        proj2(_, _) => prf.proj2(Eq(Bool, x'.eq(y'), True), Eq(Nat, x', y'))
                            .cong(Nat, Nat, x', y', comatch { ap(_, _, z) => S(z) }),
                }),
            },
        },
    }
}

def Nat.geq(y: Nat): Bool {
    Z => y.match {
        Z => True,
        S(_) => False,
    },
    S(x) => y.match {
        Z => True,
        S(y') => x.geq(y')
    }
}

data LE(x y: Nat) {
    LERefl(x: Nat): LE(x, x),
    LESucc(x y: Nat, h: LE(x, y)): LE(x, S(y)),
}

def Top.nat_geq_reflection(x y: Nat)
    : Or(
        And(Eq(Bool, x.geq(y), False), LE(S(x), y)),
        And(Eq(Bool, x.geq(y), True), LE(y, x))
    ) {
    Unit => ?,
}

data Typ {
    FunT(t1 t2: Typ),
    VarT(x: Nat),
}

data Ctx {
    Nil,
    Cons(t: Typ, ts: Ctx),
}

def Ctx.append(other: Ctx): Ctx {
    Nil => other,
    Cons(t, ts) => Cons(t, ts.append(other))
}

def Ctx.len: Nat {
    Nil => 0,
    Cons(_, ts) => S(ts.len)
}

def (self: Ctx).inversion: Or(Eq(Ctx, self, Nil), Exists(Typ, comatch { ap(_, _, t) => Exists(Ctx, comatch { ap(_, _, ts) => Eq(Ctx, self, Cons(t, ts))}) })) {
    Nil => Inl(Eq(Ctx, Nil, Nil), Exists(Typ, comatch { ap(_, _, t) => Exists(Ctx, comatch { ap(_, _, ts) => Eq(Ctx, Nil, Cons(t, ts))}) }), Refl(Ctx, Nil)),
    Cons(x, xs) => Inr(Eq(Ctx, Cons(x, xs), Nil), Exists(Typ, comatch { ap(_, _, t) => Exists(Ctx, comatch { ap(_, _, ts) => Eq(Ctx, Cons(x, xs), Cons(t, ts))}) }),
        MkExists(Typ, comatch { ap(_, _, t) => Exists(Ctx, comatch { ap(_, _, ts) => Eq(Ctx, Cons(x, xs), Cons(t, ts))}) },
            x, MkExists(Ctx, comatch { ap(_, _, ts) => Eq(Ctx, Cons(x, xs), Cons(x, ts) )}, xs, Refl(Ctx, Cons(x, xs)))
        )
    ),
}

def (ctx1: Ctx).append_assoc(ctx2 ctx3: Ctx): Eq(Ctx, ctx1.append(ctx2.append(ctx3)), ctx1.append(ctx2).append(ctx3)) {
    Nil => Refl(Ctx, ctx2.append(ctx3)),
    Cons(x, xs) => xs.append_assoc(ctx2, ctx3)
        .cong(Ctx, Ctx,
            xs.append(ctx2.append(ctx3)),
            xs.append(ctx2).append(ctx3),
            comatch { ap(_, _, xs) => Cons(x, xs) }),
}

data Elem(x: Nat, t: Typ, ctx: Ctx) {
    Here(t: Typ, ts: Ctx): Elem(Z, t, Cons(t, ts)),
    There(x: Nat, t: Typ, t2: Typ, ts: Ctx, prf: Elem(x, t, ts)): Elem(S(x), t, Cons(t2, ts)),
}

def Elem(x, t, Nil).empty_absurd(x: Nat, t: Typ) : Bot {
    Here(_, _) absurd,
    There(_, _, _, _, _) absurd,
}

data Top { Unit }

def Top.hole(a: Type, x: a, b: Type) : b {
    Unit => Unit.hole(a, x, b)
}

def Top.elem_type_unique(ctx: Ctx, x: Nat, s t: Typ, h1: Elem(x, s, ctx), h2: Elem(x, t, ctx)) : Eq(Typ, s, t) {
    Unit => ctx.inversion.match {
        Inl(_, _, eq_nil) => eq_nil.transport(Ctx, ctx, Nil, comatch { ap(_, _, c) => Elem(x, s, c) }, h1).match {
            Here(_, _) absurd,
            There(_, _, _, _, _) absurd,
        },
        Inr(_, _, exists_r) => exists_r.match {
            MkExists(_, _, r, exists_rs) => exists_rs.match {
                MkExists(_, _, rs, eq_cons) => eq_cons.transport(Ctx, ctx, Cons(r, rs), comatch { ap(_, _, c) => Elem(x, s, c) }, h1)
                    .match {
                        Here(_, _) => eq_cons.transport(Ctx, ctx, Cons(r, rs), comatch { ap(_, _, c) => Elem(x, t, c) }, h2)
                            .match {
                            Here(_, _) => Refl(Typ, r),
                            There(_, _, _, _, _) absurd,
                        },
                        There(x', _, _, _, h1') => eq_cons.transport(Ctx, ctx, Cons(r, rs), comatch { ap(_, _, c) => Elem(x, t, c) }, h2)
                            .match {
                                Here(_, _) absurd,
                                There(_, _, _, _, h2') => Unit.elem_type_unique(rs, x', s, t, h1', h2'),
                            },
                    },
            }
        }
    }
}

data HasType(ctx: Ctx, e: Exp, t: Typ) {
    TVar(ctx: Ctx, x: Nat, t: Typ, elem: Elem(x, t, ctx)) : HasType(ctx, Var(x), t),
    TLam(ctx: Ctx, t1: Typ, t2: Typ, e: Exp, body: HasType(Cons(t1, ctx), e, t2)) : HasType(ctx, Lam(e), FunT(t1, t2)),
    TApp(ctx: Ctx, t1: Typ, t2: Typ, e1: Exp, e2: Exp,
         e1_t: HasType(ctx, e1, FunT(t1, t2)),
         e2_t: HasType(ctx, e2, t1)): HasType(ctx, App(e1, e2), t2),
}

def HasType(ctx, Var(x), t).var_elem(ctx: Ctx, x: Nat, t: Typ): Elem(x, t, ctx) {
    TVar(_, _, _, h_elem) => h_elem,
    TLam(_, _, _, _, _) absurd,
    TApp(_, _, _, _, _, _, _) absurd,
}

data Exp {
    Var(x: Nat),
    Lam(body: Exp),
    App(lhs: Exp, rhs: Exp)
}

data Eval(e1 e2: Exp) {
    EBeta(e1 e2: Exp): Eval(App(Lam(e1), e2), e1.subst(0, e2.shift_up(0)).shift_down(0)),
    ECongApp1(e1 e1': Exp, h: Eval(e1, e1'), e2: Exp): Eval(App(e1, e2), App(e1', e2)),
    ECongApp2(e1 e2 e2': Exp, h: Eval(e2, e2')): Eval(App(e1, e2), App(e1, e2')),
    ECongLam(e1 e2: Exp, h: Eval(e1, e2)): Eval(Lam(e1), Lam(e2)),
}

data IsValue(e: Exp) {
    VLam(e: Exp): IsValue(Lam(e)),
}

data Progress(e: Exp) {
    PVal(e: Exp, h: IsValue(e)): Progress(e),
    PStep(e1 e2: Exp, h: Eval(e1, e2)): Progress(e1),
}

def Exp.shift_up(c: Nat): Exp {
    Var(x) => Var(x.geq(c).then_else(Nat, S(x), x)),
    Lam(e) => Lam(e.shift_up(S(c))),
    App(e1, e2) => App(e1.shift_up(c), e2.shift_up(c)),
}

def Exp.shift_down(c: Nat): Exp {
    Var(x) => Var(x.geq(c).then_else(Nat, x.pred, x)),
    Lam(e) => Lam(e.shift_down(S(c))),
    App(e1, e2) => App(e1.shift_down(c), e2.shift_down(c)),
}

def Exp.subst(v: Nat, by: Exp): Exp {
    Var(x) => x.eq(v).then_else(Exp, by, Var(x)),
    Lam(e) => Lam(e.subst(S(v), by.shift_up(0))),
    App(e1, e2) => App(e1.subst(v, by), e2.subst(v, by)),
}

def (self: Exp).progress(t: Typ): Fun(HasType(Nil, self, t), Progress(self))
{
    Var(x) => comatch { ap(_, _, h) => h.match {
        TVar(_, _, _, elem) => elem.empty_absurd(x, t).elim_bot(Progress(Var(x))),
        TLam(_, _, _, _, _) absurd,
        TApp(_, _, _, _, _, _, _) absurd,
    }},
    Lam(e) => comatch { ap(_, _, h) => PVal(Lam(e), VLam(e)) },
    App(e1, e2) => comatch { ap(_, _, h) =>
        h.match {
            TVar(_, _, _, _) absurd,
            TLam(_, _, _, _, _) absurd,
            TApp(_, t1, t2, _, _, e1_t, e2_t) =>
            e1.progress(FunT(t1, t2)).ap(HasType(Nil, e1, FunT(t1, t2)), Progress(e1), e1_t).match {
                PStep(_, e1', e1_eval_e1') => PStep(App(e1, e2), App(e1', e2), ECongApp1(e1, e1', e1_eval_e1', e2)),
                PVal(_, is_val) => is_val.match {
                    VLam(e) => PStep(App(Lam(e), e2), e.subst(0, e2.shift_up(0)).shift_down(0), EBeta(e, e2))
                },
            },
        }
    },
}

def Top.elem_append_lt(ctx1 ctx2: Ctx, s t: Typ, x: Nat, h_elem: Elem(x, s, ctx1.append(ctx2)), h_le: LE(S(x), ctx1.len)): Elem(x, s, ctx1.append(Cons(t, ctx2))) {
    Unit => ?,
}

def Top.elem_append_geq(ctx1 ctx2: Ctx, s t: Typ, x: Nat, h_elem: Elem(x, s, ctx1.append(ctx2)), h_le: LE(ctx1.len, x)): Elem(S(x), s, ctx1.append(Cons(t, ctx2))) {
    Unit => ?,
}

def Top.ctx_append'(t: Typ, ctx1 ctx2: Ctx, e: Exp, s: Typ, h_e: HasType(ctx1.append(ctx2), e, s)): HasType(ctx1.append(Cons(t, ctx2)), e.shift_up(ctx1.len), s) {
    Unit => h_e.match {
        TVar(_, x, _, h_elem) => Unit.nat_geq_reflection(x, ctx1.len).match {
            Inl(_, _, h) =>
                h.proj1(Eq(Bool, x.geq(ctx1.len), False), LE(S(x), ctx1.len))
                    .sym(Bool, x.geq(ctx1.len), False)
                    .transport(Bool, False, x.geq(ctx1.len),
                    comatch { ap(_, _, is_geq) => HasType(ctx1.append(Cons(t, ctx2)), Var(is_geq.then_else(Nat, S(x), x)), s) },
                    TVar(ctx1.append(Cons(t, ctx2)), x, s,
                        Unit.elem_append_lt(ctx1, ctx2, s, t, x, h_elem, h.proj2(Eq(Bool, x.geq(ctx1.len), False), LE(S(x), ctx1.len)))
                    )
                ),
            Inr(_, _, h) => h.proj1(Eq(Bool, x.geq(ctx1.len), True), LE(ctx1.len, x))
                    .sym(Bool, x.geq(ctx1.len), True)
                    .transport(Bool, True, x.geq(ctx1.len),
                    comatch { ap(_, _, is_geq) => HasType(ctx1.append(Cons(t, ctx2)), Var(is_geq.then_else(Nat, S(x), x)), s) },
                    TVar(ctx1.append(Cons(t, ctx2)), S(x), s,
                        Unit.elem_append_geq(ctx1, ctx2, s, t, x, h_elem, h.proj2(Eq(Bool, x.geq(ctx1.len), True), LE(ctx1.len, x)))
                    )
                )
        },
        TLam(_, t1, t2, e, h_body) =>
            TLam(
                ctx1.append(Cons(t, ctx2)),
                t1, t2, e.shift_up(Cons(t1, ctx1).len),
                Cons(t1, Nil).append_assoc(ctx1, Cons(t, ctx2))
                    .transport(
                        Ctx,
                        Cons(t1, ctx1).append(Cons(t, ctx2)),
                        Cons(t1, ctx1.append(Cons(t, ctx2))),
                        comatch { ap(_, _, ctx) => HasType(ctx, e.shift_up(Cons(t1, ctx1).len), t2) },
                        Unit.ctx_append'(t, Cons(t1, ctx1), ctx2, e, t2,
                                        Cons(t1, Nil).append_assoc(ctx1, ctx2)
                                            .transport(
                                                Ctx,
                                                Cons(t1, ctx1.append(ctx2)),
                                                Cons(t1, ctx1).append(ctx2),
                                                comatch { ap(_, _, ctx) => HasType(ctx, e, t2) },
                                                h_body
                                            ): HasType(Cons(t1, ctx1).append(ctx2), e, t2)
                                    ): HasType(Cons(t1, ctx1).append(Cons(t, ctx2)), e.shift_up(Cons(t1, ctx1).len), t2)
                    ): HasType(Cons(t1, ctx1.append(Cons(t, ctx2))), e.shift_up(Cons(t1, ctx1).len), t2)
            ),
        TApp(_, t1, t2, e1, e2, h_e1, h_e2) =>
            TApp(ctx1.append(Cons(t, ctx2)), t1, t2,
                e1.shift_up(ctx1.len),
                e2.shift_up(ctx1.len),
                Unit.ctx_append'(t, ctx1, ctx2, e1, FunT(t1, t2), h_e1),
                Unit.ctx_append'(t, ctx1, ctx2, e2, t1, h_e2)
            ),
    },
}

def Top.ctx_append(ctx: Ctx, s t: Typ, e: Exp, h_e: HasType(ctx, e, s)): HasType(Cons(t, ctx), e.shift_up(Z), s) {
    Unit => Unit.ctx_append'(t, Nil, ctx, e, s, h_e)
}

def (self: Exp).subst_lemma(ctx: Ctx, s t: Typ, x: Nat, by: Exp, h_elem: Elem(x, s, ctx), h_by: HasType(ctx, by, s)): Fun(HasType(ctx, self, t), HasType(ctx, self.subst(x, by), t)) {
    Var(y) => comatch { ap(_, _, h_self) => Unit.nat_eq_reflection(y, x).match {
        Inl(_, _, prf) => prf
            .sym(Bool, y.eq(x), False)
            .transport(Bool, False, y.eq(x), comatch {
            ap(_, _, z) => HasType(ctx, z.then_else(Exp, by, Var(y)), t)
        }, h_self),
        Inr(_, _, prf) => prf.proj1(Eq(Bool, y.eq(x), True), Eq(Nat, y, x))
            .sym(Bool, y.eq(x), True)
            .transport(Bool, True, y.eq(x), comatch { ap(_, _, z) => HasType(ctx, z.then_else(Exp, by, Var(y)), t) },
                Unit.elem_type_unique(ctx, x, s, t, h_elem,
                    prf.proj2(Eq(Bool, y.eq(x), True), Eq(Nat, y, x))
                        .transport(Nat, y, x, comatch { ap(_, _, r) => HasType(ctx, Var(r), t) }, h_self)
                        .var_elem(ctx, x, t)
                )
                .transport(Typ, s, t, comatch { ap(_, _, r) => HasType(ctx, by, r) }, h_by)
            ),
        }
    },
    App(e1, e2) => comatch { ap(_, _, h_self) => h_self.match {
        TVar(_, _, _, _) absurd,
        TLam(_, _, _, _, _) absurd,
        TApp(_, t1, t2, e1, e2, e1_t, e2_t) => TApp(ctx, t1, t2, e1.subst(x, by), e2.subst(x, by),
            e1.subst_lemma(ctx, s, FunT(t1, t2), x, by, h_elem, h_by)
                .ap(HasType(ctx, e1, FunT(t1, t2)), HasType(ctx, e1.subst(x, by), FunT(t1, t2)), e1_t),
            e2.subst_lemma(ctx, s, t1, x, by, h_elem, h_by)
                .ap(HasType(ctx, e2, t1), HasType(ctx, e2.subst(x, by), t1), e2_t),
        ),
    }},
    Lam(e) => comatch {
        ap(_, _, h_self) => h_self.match {
            TVar(_, _, _, _) absurd,
            TApp(_, _, _, _, _, _, _) absurd,
            TLam(ctx, t1, t2, e, h_body) => TLam(ctx, t1, t2, e.subst(S(x), by.shift_up(Z)),
                e.subst_lemma(Cons(t1, ctx), s, t2, S(x), by.shift_up(Z),
                        There(x, s, t1, ctx, h_elem),
                        Unit.ctx_append(ctx, s, t1, by, h_by)
                    )
                    .ap(HasType(Cons(t1, ctx), e, t2),
                        HasType(Cons(t1, ctx), e.subst(S(x), by.shift_up(Z)), t2),
                        h_body
                    ),
            ),
        },
    },
}

def (e: Exp).subst_lemma''(ctx1 ctx2: Ctx, by: Exp, s t: Typ): Fun(HasType(Cons(t, ctx1.append(ctx2)), e.subst(ctx1.len, by), s), HasType(ctx1.append(ctx2), e.subst(ctx1.len, by).shift_down(ctx1.len), s)) {
    Var(x) => \h_t. ?,
    App(_, _) => ?,
    Lam(_) => ?,
}

def Top.subst_lemma'(ctx: Ctx, e: Exp, s t: Typ, by: Exp, h_e: HasType(Cons(t, ctx), e, s), h_by: HasType(ctx, by, t)): HasType(ctx, e.subst(Z, by).shift_down(Z), s) {
    Unit => ?,
}

def (self: Exp).preservation(
    ctx: Ctx, e2: Exp, t: Typ,
): Fun(HasType(ctx, self, t), Fun(Eval(self, e2), HasType(ctx, e2, t)))
{
    Var(_) => \h_t. \h_eval. h_eval.match {
        EBeta(_, _) absurd,
        ECongApp1(_, _, _, _) absurd,
        ECongApp2(_, _, _, _) absurd,
        ECongLam(_, _, _) absurd,
    },
    Lam(_) => \h_t. \h_eval. h_eval.match {
        EBeta(_, _) absurd,
        ECongApp1(_, _, _, _) absurd,
        ECongApp2(_, _, _, _) absurd,
        ECongLam(e1, e2, h) => h_t.match {
            TVar(_, _, _, _) absurd,
            TApp(_, _, _, _, _, _, _) absurd,
            TLam(_, t1, t2, _, h_body) =>
                TLam(ctx, t1, t2, e2, e1.preservation(Cons(t1, ctx), e2, t2)
                    .ap(HasType(Cons(t1, ctx), e1, t2), Fun(Eval(e1, e2), HasType(Cons(t1, ctx), e2, t2)), h_body)
                    .ap(Eval(e1, e2), HasType(Cons(t1, ctx), e2, t2), h)
                ),
        },
    },
    App(_, e2) => \h_t. h_t.match {
        TVar(_, _, _, _) absurd,
        TLam(_, _, _, _, _) absurd,
        TApp(_, t1, t2, _, _, e1_t, e2_t) => \h_eval. h_eval.match {
            ECongLam(_, _, _) absurd,
            ECongApp1(_, _, _, _) => ?,
            ECongApp2(_, _, _, _) => ?,
            EBeta(e1, _) => ?
        }
    }
}
